<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>EXODUS — 갈라진 바다 (No-Babel Build)</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- htm: JSX 없이 템플릿 문자열로 React.createElement 사용 -->
    <script src="https://unpkg.com/htm@3.1.1/dist/htm.umd.js" crossorigin></script>
    <style>
      html,body,#root { height: 100%; }
      body { margin:0; background:#0b0a07; }
      #error-overlay { position: fixed; inset: 0; display:none; padding:16px; background: rgba(0,0,0,0.9); color:#fff; z-index:99999; overflow:auto; }
      #error-overlay pre { white-space: pre-wrap; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <div id="error-overlay"><div class="max-w-3xl mx-auto">
      <h2 class="text-red-400 text-xl font-bold mb-2">⚠️ 런타임 오류</h2>
      <pre id="error-text" class="text-sm"></pre>
    </div></div>

    <script>
      // 오류 오버레이
      (function(){
        function show(msg){
          var o=document.getElementById('error-overlay'), t=document.getElementById('error-text');
          if(o&&t){ t.textContent=String(msg||'Unknown error'); o.style.display='block'; }
        }
        window.addEventListener('error',function(e){ show((e.error&&e.error.stack)||e.message||e.filename+':'+e.lineno); });
        window.addEventListener('unhandledrejection',function(e){ show((e.reason&&e.reason.stack)||String(e.reason)); });
      })();
    </script>

    <script>
      // React + htm 바인딩
      const h = React.createElement;
      const html = htm.bind(h);

      // ===== 유틸/상수 =====
      const clamp = (n, min=0, max=100) => Math.max(min, Math.min(max, n));
      const rnd = (min, max) => Math.floor(Math.random()*(max-min+1))+min;

      const DIFFICULTY_KEYS = ["쉬움","보통","어려움","악몽"];
      const DIFF_PRESETS = {
        "쉬움": { desc:"자원 넉넉, 사건 완화, 자동 전진 1",
          init:{ bread:8, herbs:5, bandage:4, people:220, stress:12, chase:15, maxDistance:10 },
          mods:{ baseChaseGain:4, stressGainPerTurn:2, eventMul:0.8, autoAdvance:1 },
          deckDelta:(ids)=>[ids.prayer, ids.hide]
        },
        "보통": { desc:"기본 밸런스",
          init:{ bread:6, herbs:4, bandage:3, people:200, stress:15, chase:20, maxDistance:10 },
          mods:{ baseChaseGain:5, stressGainPerTurn:3, eventMul:1.0, autoAdvance:1 }
        },
        "어려움": { desc:"사건↑, 추격 가속↑, 자동 전진 1",
          init:{ bread:5, herbs:3, bandage:2, people:190, stress:18, chase:25, maxDistance:11 },
          mods:{ baseChaseGain:6, stressGainPerTurn:4, eventMul:1.2, autoAdvance:1 }
        },
        "악몽": { desc:"사건↑↑, 추격 가속↑↑, 자동 전진 0",
          init:{ bread:4, herbs:2, bandage:2, people:180, stress:20, chase:28, maxDistance:12 },
          mods:{ baseChaseGain:7, stressGainPerTurn:5, eventMul:1.4, autoAdvance:0 }
        },
      };

      let autoId = 0;
      const cid = () => "C"+(autoId++);

      function createCards(){
        const c={};
        const add=(card)=>{ const id=cid(); c[id]=Object.assign({id},card); return id; };

        const bread = add({ name:"누룩 없는 빵 배급", cost:1, tint:"amber-400", text:"빵 -1 ➜ 스트레스 -8, 굶주림 사건 확률↓",
          canUse:(s)=>s.bread>0,
          use:(s)=>Object.assign({},s,{ bread:s.bread-1, stress:clamp(s.stress-8), log:["빵을 배급했습니다. 스트레스가 줄었습니다.", ...s.log] })
        });
        const herb  = add({ name:"약초 치료", cost:1, tint:"emerald-400", text:"약초 -1 ➜ 질병/부상 피해 완화, 스트레스 -4",
          canUse:(s)=>s.herbs>0,
          use:(s)=>Object.assign({},s,{ herbs:s.herbs-1, stress:clamp(s.stress-4), log:["약초로 치료했습니다. 피해가 줄어듭니다.", ...s.log] })
        });
        const band  = add({ name:"붕대 감기", cost:1, tint:"rose-300", text:"붕대 -1 ➜ 부상 사망 방지, 스트레스 -3",
          canUse:(s)=>s.bandage>0,
          use:(s)=>Object.assign({},s,{ bandage:s.bandage-1, stress:clamp(s.stress-3), log:["붕대를 사용했습니다. 부상자 회복에 도움.", ...s.log] })
        });
        const decoy = add({ name:"미끼 작전", cost:1, tint:"yellow-300", text:"추격 -10 (최소 0)",
          use:(s)=>Object.assign({},s,{ chase:clamp(s.chase-10), log:["미끼를 사용해 추격을 따돌렸습니다.", ...s.log] })
        });
        const scout = add({ name:"선발대 정찰", cost:1, tint:"sky-300", text:"추격 -5, 스트레스 -5",
          use:(s)=>Object.assign({},s,{ chase:clamp(s.chase-5), stress:clamp(s.stress-5), log:["정찰 성공! 안전 경로를 발견했습니다.", ...s.log] })
        });
        const night = add({ name:"야간 이동", cost:1, tint:"indigo-300", text:"추격 -6, 스트레스 +4",
          use:(s)=>Object.assign({},s,{ chase:clamp(s.chase-6), stress:clamp(s.stress+4), log:["밤을 틈타 이동했습니다. 추격이 줄었습니다(피로↑).", ...s.log] })
        });
        const march = add({ name:"빠른 행군", cost:2, tint:"orange-300", text:"거리 +1, 스트레스 +6, 추격 +4",
          use:(s)=>Object.assign({},s,{ distance:clamp(s.distance+1,0,s.maxDistance), stress:clamp(s.stress+6), chase:clamp(s.chase+4), log:["빠른 행군으로 더 전진했습니다.", ...s.log] })
        });
        const hide  = add({ name:"모래언덕 은닉", cost:1, tint:"amber-500", text:"추격 -8, 에너지 +1(최대 초과 불가)",
          use:(s)=>Object.assign({},s,{ chase:clamp(s.chase-8), energy:clamp(s.energy+1,0,s.maxEnergy), log:["모래언덕에 숨었습니다. 숨 고르기!", ...s.log] })
        });
        const prayer= add({ name:"기도", cost:1, tint:"cyan-300", text:"스트레스 -10 (최소 0)",
          use:(s)=>Object.assign({},s,{ stress:clamp(s.stress-10), log:["기도로 마음이 평안해졌습니다.", ...s.log] })
        });
        const inspire= add({ name:"격려", cost:0, tint:"emerald-300", text:"스트레스 -4",
          use:(s)=>Object.assign({},s,{ stress:clamp(s.stress-4), log:["격려의 말이 백성들에게 힘이 되었습니다.", ...s.log] })
        });

        return { cards:c, ids:{ bread, herb, band, decoy, scout, night, march, hide, prayer, inspire } };
      }

      function buildStartDeck(ids, diffKey){
        const base=[ ids.bread, ids.bread, ids.herb, ids.band, ids.decoy, ids.scout, ids.night, ids.march, ids.march, ids.hide, ids.prayer, ids.inspire, ids.inspire ];
        const delta = DIFF_PRESETS[diffKey] && DIFF_PRESETS[diffKey].deckDelta ? DIFF_PRESETS[diffKey].deckDelta(ids) : [];
        return base.concat(delta);
      }

      function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); const t=a[i]; a[i]=a[j]; a[j]=t;} return a; }

      function createGame(difficulty){
        const ci = createCards();
        const cards = ci.cards, ids=ci.ids;
        const deck = buildStartDeck(ids,difficulty);
        const draw = shuffle(deck);
        const preset = DIFF_PRESETS[difficulty];
        const init = preset? preset.init : {};
        return {
          turn:1, energy:3, maxEnergy:3,
          deck, discard:[], draw, hand:[], cards,
          bread:(init.bread!=null?init.bread:6),
          herbs:(init.herbs!=null?init.herbs:4),
          bandage:(init.bandage!=null?init.bandage:3),
          people:(init.people!=null?init.people:200),
          lost:0, stress:(init.stress!=null?init.stress:15),
          chase:(init.chase!=null?init.chase:20),
          distance:0, maxDistance:(init.maxDistance!=null?init.maxDistance:10),
          log:["출발 준비가 끝났습니다. (탈출 시작)"],
          scene:"menu", difficulty, mods:preset.mods
        };
      }

      function drawUpTo(s, n){ n=(n==null?5:n); s=Object.assign({},s,{ hand:s.hand.slice(), draw:s.draw.slice(), discard:s.discard.slice() });
        while(s.hand.length<n){
          if(s.draw.length===0){ if(s.discard.length===0) break; s.draw=shuffle(s.discard); s.discard=[]; }
          const id=s.draw.shift(); if(id==null) break; s.hand.push(id);
        }
        return s;
      }

      function startTurn(s){ s=Object.assign({},s,{ energy:s.maxEnergy }); return drawUpTo(s,5); }

      function resolveEndTurnEvents(s){
        let log=s.log.slice(); let people=s.people,lost=s.lost,stress=s.stress,chase=s.chase,bread=s.bread,herbs=s.herbs,bandage=s.bandage;
        const baseChaseGain=s.mods.baseChaseGain+Math.floor(s.distance/3);
        chase=clamp(chase+baseChaseGain); stress=clamp(stress+s.mods.stressGainPerTurn);
        if(bread<=0 && Math.random()<0.4){ stress=clamp(stress+8); log.unshift("식량이 부족해 사기가 떨어졌습니다 (+스트레스)."); }
        const rawChance=0.15+stress/200+chase/300; const eventChance=Math.min(rawChance*s.mods.eventMul,0.6);
        if(Math.random()<eventChance){
          const roll=Math.random();
          if(roll<0.33){ let deaths=rnd(1,5); if(herbs>0) deaths=Math.max(0,deaths-2); if(bandage>0) deaths=Math.max(0,deaths-1);
            people=Math.max(0,people-deaths); lost+=deaths; stress=clamp(stress+6);
            log.unshift(deaths>0?("질병이 돌았습니다 (-"+deaths+"명)."):"질병이 돌았지만 큰 피해는 없었습니다.");
          }else if(roll<0.66){ const leave=rnd(0,4); people=Math.max(0,people-leave); lost+=leave; stress=clamp(stress+5);
            log.unshift(leave>0?("내분이 발생했습니다 (-"+leave+"명 이탈)."):"사소한 다툼이 있었지만 수습했습니다.");
          }else{ chase=clamp(chase+rnd(5,12)); stress=clamp(stress+4); log.unshift("파라오의 병거가 속도를 냅니다 (추격↑)."); }
        }
        const distance=clamp(s.distance+s.mods.autoAdvance,0,s.maxDistance);
        return Object.assign({},s,{ people,lost,stress,chase,bread,herbs,bandage,distance,log });
      }

      function endTurn(s){
        s=Object.assign({},s,{ turn:s.turn+1, energy:s.maxEnergy });
        s.discard=s.discard.concat(s.hand); s.hand=[];
        s=resolveEndTurnEvents(s);
        s=drawUpTo(s,5);
        if(s.chase>=100 || s.people<=0) return Object.assign({},s,{ scene:"defeat", log:["이집트 군대에게 추격당했습니다...", ...s.log] });
        if(s.distance>=s.maxDistance) return Object.assign({},s,{ scene:"victory" });
        return s;
      }

      function playCard(state, id){
        const card = state.cards[id];
        if(!card) return state;
        if(state.energy < card.cost) return state;
        if(card.canUse && !card.canUse(state)) return state;
        let s = Object.assign({},state,{ energy: state.energy - card.cost });
        s = card.use(s);
        const hand = s.hand.slice(); const idx = hand.indexOf(id); if(idx!==-1) hand.splice(idx,1);
        s.hand = hand; s.discard=[id].concat(s.discard);
        return s;
      }

      // ===== UI 컴포넌트 (htm) =====
      const TINT_BG = { "amber-400":"bg-amber-400","emerald-400":"bg-emerald-400","rose-300":"bg-rose-300","yellow-300":"bg-yellow-300","sky-300":"bg-sky-300","indigo-300":"bg-indigo-300","orange-300":"bg-orange-300","amber-500":"bg-amber-500","cyan-300":"bg-cyan-300","emerald-300":"bg-emerald-300","amber-300":"bg-amber-300" };

      function Bar({label,val,max=100,color}){
        const pct = Math.round((val / max) * 100);
        return html`<div class="w-full">
          <div class="flex items-center justify-between text-xs text-amber-100/90">
            <span class="tracking-wider">${label}</span>
            <span class="font-semibold">${val}/${max}</span>
          </div>
          <div class="h-2 w-full rounded-full bg-amber-900/40 overflow-hidden">
            <div class=${"h-2 "+color} style=${{width: pct+"%"}}></div>
          </div>
        </div>`;
      }

      function MeterRow({s}){
        return html`<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-3">
          <div class="flex gap-2 items-center">${Bar({label:"인구", val:s.people, max:300, color:"bg-amber-300"})}</div>
          <div class="flex gap-2 items-center">${Bar({label:"스트레스", val:s.stress, color:"bg-rose-400"})}</div>
          <div class="flex gap-2 items-center">${Bar({label:"추격", val:s.chase, color:"bg-yellow-300"})}</div>
          <div class="flex gap-2 items-center">${Bar({label:"거리", val:s.distance, max:s.maxDistance, color:"bg-orange-400"})}</div>
          <div class="flex gap-2 items-center">${Bar({label:"에너지", val:s.energy, max:s.maxEnergy, color:"bg-emerald-400"})}</div>
        </div>`;
      }

      function ResourcePills({s}){
        function pill(label,val,cls){ return html`<div class=${"flex items-center gap-1 px-2 py-1 rounded-full text-xs font-semibold "+cls}>
          <span>${label}</span><span class="opacity-90">${val}</span></div>`; }
        return html`<div class="flex flex-wrap gap-2">
          ${pill("빵",s.bread,"bg-amber-300/20 text-amber-100 border border-amber-300/30")}
          ${pill("약초",s.herbs,"bg-emerald-300/20 text-emerald-100 border border-emerald-300/30")}
          ${pill("붕대",s.bandage,"bg-rose-300/20 text-rose-100 border border-rose-300/30")}
          <div class="flex items-center gap-2 text-amber-100/80 text-xs"><span>턴</span><span class="font-bold">${s.turn}</span></div>
        </div>`;
      }

      function MapTrack({s}){
        const nodes = Array.from({length:s.maxDistance+1}, (_,i)=>i);
        return html`<div class="flex items-center justify-between gap-2 w-full">
          ${nodes.map(i => html`<div class=${"relative w-6 h-6 sm:w-7 sm:h-7 rounded-full flex items-center justify-center text-[10px] sm:text-xs font-bold "+(i<=s.distance?"bg-amber-300 text-amber-950":"bg-amber-950/40 text-amber-100/60")}>${i}
            ${i===s.maxDistance? html`<div class="absolute -top-3 -right-3 text-sky-300">🌊</div>`:null}
          </div>`)}
        </div>`;
      }

      function CardView({card, disabled, onPlay}){
        const tintClass = TINT_BG[card.tint||"amber-300"];
        return html`<button disabled=${disabled} onClick=${onPlay}
          class=${"group relative w-44 h-56 rounded-2xl p-3 text-left shadow-lg bg-amber-950/40 border border-amber-700/40 hover:border-amber-400/50 transition "+(disabled?"opacity-50 cursor-not-allowed":"hover:-translate-y-0.5")}>
          <div class=${"absolute inset-x-0 -top-1 h-1 rounded-t-2xl "+tintClass}></div>
          <div class="text-amber-100 font-bold text-sm pr-8 leading-tight">${card.name}</div>
          <div class="absolute top-3 right-3 w-8 h-8 rounded-full bg-amber-900/60 border border-amber-600/50 flex items-center justify-center text-amber-100 font-extrabold">${card.cost}</div>
          <div class="mt-3 text-[13px] text-amber-100/90 leading-snug">${card.text}</div>
          <div class="absolute bottom-3 left-3 text-[10px] uppercase tracking-wider text-amber-200/60">Action</div>
        </button>`;
      }

      function Log({s}){
        return html`<div class="h-40 overflow-auto rounded-xl p-3 bg-amber-950/40 border border-amber-700/40 text-amber-100 text-sm space-y-2">
          ${s.log.map((l,i)=> html`<div key=${i} class="opacity-90">• ${l}</div>`)}
        </div>`;
      }

      function TopBar(){
        return html`<div class="flex items-center justify-between">
          <div class="text-amber-100 text-xl sm:text-2xl font-extrabold tracking-wide flex items-center gap-2">
            <span>EXODUS</span><span class="text-amber-300/90">/ 갈라진 바다</span>
          </div>
          <div class="text-amber-200/70 text-xs sm:text-sm">덱빌딩 로그라이크 웹게임</div>
        </div>`;
      }

      // ===== App =====
      function App(){
        const savedDiff = (typeof window!=="undefined" && localStorage.getItem("exodus_diff")) || "보통";
        const [difficulty, setDifficulty] = React.useState(savedDiff);
        const [state, setState] = React.useState(createGame(savedDiff));
        const [result, setResult] = React.useState(null);

        function startGame(){
          const g = createGame(difficulty);
          const s = startTurn(g);
          setState(s);
          setResult(null);
          try{ localStorage.setItem("exodus_diff", difficulty); }catch(e){}
        }

        React.useEffect(()=>{
          if(state.scene==="victory"){
            const score = (function calcScore(s){
              const survivors = s.people;
              const speed = Math.max(0,(12+(s.difficulty==="악몽"?2:0))-s.turn);
              const safety = 100 - s.chase;
              const morale = 100 - s.stress;
              const score = survivors*2 + speed*100 + safety*5 + morale*3;
              return Math.max(0, Math.round(score));
            })(state);
            const r = (function saveAndRank(score){
              const key="exodus_scores_v1";
              let arr=[]; try{ arr=JSON.parse(localStorage.getItem(key)||"[]"); }catch(e){}
              arr.push(score); arr.sort((a,b)=>b-a);
              try{ localStorage.setItem(key, JSON.stringify(arr)); }catch(e){}
              const idx=arr.indexOf(score), n=arr.length;
              const percentileTop = Math.round((1 - idx/n)*10000)/100;
              return { rank:idx+1, total:n, percentileTop, board:arr.slice(0,10) };
            })(score);
            setResult({ score, percentile:r.percentileTop, rank:r.rank, total:r.total, board:r.board });
          }
        }, [state.scene]);

        const play = (id)=> setState(s=> playCard(s,id));
        const end  = ()=> setState(s=> endTurn(s));
        const canPlay = (c)=> state.energy>=c.cost && (!c.canUse || c.canUse(state));

        const desertBg = "bg-gradient-to-b from-amber-950 via-amber-900 to-amber-800";
        const seaBg = "bg-gradient-to-b from-sky-900 via-sky-700 to-sky-600";

        // Scenes
        if(state.scene==="menu"){
          return html`<div class=${"min-h-screen "+desertBg+" p-6 sm:p-8"}>
            <div class="max-w-6xl mx-auto space-y-8">
              ${TopBar()}
              <div class="grid lg:grid-cols-2 gap-8 items-center">
                <div class="space-y-6">
                  <h1 class="text-amber-100 text-3xl sm:text-4xl font-extrabold">모세와 함께 홍해로</h1>
                  <p class="text-amber-100/90 leading-relaxed">이집트의 추격을 피해 백성을 이끌고 홍해까지 전진하세요.</p>
                  <div class="space-y-2">
                    <div class="text-amber-200/80 text-sm">난이도</div>
                    <div class="flex flex-wrap gap-2">
                      ${DIFFICULTY_KEYS.map(k => html`<button key=${k} onClick=${()=>setDifficulty(k)}
                        class=${"px-3 py-2 rounded-xl text-sm border "+(k===difficulty?"bg-amber-300 text-amber-950 border-amber-400":"bg-amber-950/30 text-amber-100 border-amber-700/40 hover:border-amber-400/40")}>${k}</button>`)}
                    </div>
                    <div class="text-amber-200/70 text-xs">${DIFF_PRESETS[difficulty].desc}</div>
                  </div>
                  <button onClick=${startGame} class="px-5 py-3 rounded-2xl bg-amber-300 text-amber-950 font-extrabold shadow hover:shadow-lg">여정 시작</button>
                </div>
                <div class="rounded-3xl border border-amber-700/40 p-6 bg-amber-950/30">
                  <div class="text-amber-200/80 text-sm mb-3">손패 바꾸기는 무한정 사용할 수 있습니다 적재적소에 활용하세요</div>
                  <div class="aspect-video rounded-2xl bg-amber-900/50 flex items-center justify-center">
                    <div class="text-amber-200/70">사막 위 행렬… 모래바람… 이스라엘 백성들의 운명은?</div>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
        }

        if(state.scene==="victory"){
          return html`<div class=${"min-h-screen "+seaBg+" p-6 sm:p-8"}>
            <div class="max-w-6xl mx-auto space-y-6">
              <div class="flex items-center justify-between">
                <div class="text-sky-100 text-2xl sm:text-3xl font-extrabold tracking-wide flex items-center gap-2">
                  <span>홍해가 갈라졌습니다!</span><span>🌊</span>
                </div>
                <button onClick=${startGame} class="px-4 py-2 rounded-xl bg-sky-300 text-sky-950 font-bold">다시 도전</button>
              </div>
              ${result? html`<div class="text-sky-100 text-sm">점수: ${result.score} · 상위 ${result.percentile.toFixed(2)}%</div>`:null}
            </div>
          </div>`;
        }

        if(state.scene==="defeat"){
          return html`<div class=${"min-h-screen "+desertBg+" p-6 sm:p-8"}>
            <div class="max-w-4xl mx-auto space-y-6">
              <div class="text-amber-100 text-2xl sm:text-3xl font-extrabold">패배… 추격을 피하지 못했습니다</div>
              <button onClick=${startGame} class="px-5 py-3 rounded-2xl bg-amber-300 text-amber-950 font-extrabold">다시 시도</button>
            </div>
          </div>`;
        }

        // play scene
        return html`<div class=${"min-h-screen "+desertBg+" p-6 sm:p-8"}>
          <div class="max-w-7xl mx-auto space-y-6">
            ${TopBar()}
            <div class="grid lg:grid-cols-3 gap-6">
              <div class="lg:col-span-2 space-y-4">
                ${MeterRow({s:state})}
                ${ResourcePills({s:state})}
                <div class="rounded-3xl p-4 bg-amber-950/30 border border-amber-700/40">
                  <div class="text-amber-200/80 text-sm mb-2">경로 진행</div>
                  ${MapTrack({s:state})}
                </div>
              </div>
              <div class="space-y-3">
                <div class="rounded-3xl p-4 bg-amber-950/30 border border-amber-700/40">
                  <div class="text-amber-200/80 text-sm mb-2">사건 로그</div>
                  ${Log({s:state})}
                </div>
                <div class="flex gap-3">
                  <button onClick=${()=>setState(startTurn)} class="px-4 py-2 rounded-xl bg-amber-300 text-amber-950 font-bold">손패 보충</button>
                  <button onClick=${()=>setState(endTurn)} class="px-4 py-2 rounded-xl bg-amber-100/90 text-amber-950 font-bold border border-amber-700/40">턴 종료</button>
                </div>
              </div>
            </div>
            <div class="rounded-3xl p-4 bg-amber-950/30 border border-amber-700/40">
              <div class="text-amber-200/80 text-sm mb-3">손패 (에너지 ${state.energy}/${state.maxEnergy})</div>
              <div class="flex flex-wrap gap-3">
                ${state.hand.map((id, idx)=> CardView({ card: state.cards[id], disabled: !(state.energy>=state.cards[id].cost && (!state.cards[id].canUse || state.cards[id].canUse(state))), onPlay: ()=> setState(s=> playCard(s,id)) }))}
              </div>
              <div class="mt-3 text-amber-200/70 text-xs">드로우 ${state.draw.length} · 버림 ${state.discard.length}</div>
            </div>
          </div>
        </div>`;
      }

      // Mount
      (function mount(){
        try{
          const rootEl = document.getElementById('root');
          const root = ReactDOM.createRoot(rootEl);
          root.render(html`<${App} />`);
        }catch(e){
          var o=document.getElementById('error-overlay'), t=document.getElementById('error-text');
          if(o&&t){ t.textContent = e.stack || String(e); o.style.display='block'; }
          throw e;
        }
      })();
    </script>
  </body>
</html>
